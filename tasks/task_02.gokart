let inputArray = \_ ->
  let size = s2i (read ()); in
  let vec = vectorIntFill size 0; in
  letrec go = \cur -> if (cur < size) then (let _ = vectorIntUpdateMut vec (cur, s2i (read ())); in go (cur + 1)) else (); in
  let _ = go 0; in
  vec; in

let printArray = \vec ->
  (let size = vectorIntLength vec; in
  letrec go = \cur -> if (cur < size) then (let _ = print (i2s (vectorIntGet vec cur)); in go (cur + 1)) else (); in
  go 0); in

let merge = \l r ->
  let vec = vectorIntFill (vectorIntLength l + vectorIntLength r) 0; in
  letrec go = \li ri ->
    if ((li < vectorIntLength l) * (ri < vectorIntLength r))
        then let (lv, rv) = (vectorIntGet l li, vectorIntGet r ri); in
            let _ = vectorIntUpdateMut vec (li + ri, if (lv < rv) then lv else rv); in
            if (lv < rv) then go (li + 1) ri else go li (ri + 1)
        else if (li < vectorIntLength l)
            then
              let _ = vectorIntUpdateMut vec (li + ri, vectorIntGet l li); in
              go (li + 1) ri
            else if (ri < vectorIntLength r)
            then
              let _ = vectorIntUpdateMut vec (li + ri, vectorIntGet r ri); in
              go li (ri + 1)
            else (); in
  let _ = go 0 0; in
  vec; in

let mergeSort = \vec ->
  letrec go = \leftIdx rightIdx ->
    if ((rightIdx - leftIdx) == 1)
    then vectorIntFill 1 (vectorIntGet vec leftIdx)
    else
      let mid = (rightIdx + leftIdx) / 2; in
      merge (go leftIdx mid) (go mid rightIdx); in
  go 0 (vectorIntLength vec); in

let vec = inputArray (); in
let _ = print "vec:"; in
let _ = printArray vec; in
let _ = print "sorted:"; in
let _ = printArray (mergeSort vec); in
()
