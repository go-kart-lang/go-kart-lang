Pipe<T>: Vec<T> = {
    <mut v:(<T> "|")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


pub TypeDef: TypeDef<'input> = {
    "data" <type_name: "uidentifier"> "=" <constructors: Pipe<Constructor>> => {
        TypeDef { type_name, constructors }
    }
}



AtomicExpr: Rc<RefCell<Ast<'input>>> = {
    <l: Literal> => Rc::new(RefCell::new(Ast::Literal(l))),
    <name: "identifier"> => Rc::new(RefCell::new(Ast::Var(name))),
    <name: "uidentifier"> => Rc::new(RefCell::new(Ast::Var(name))),
    "(" <a: Ast> ")" => a
}

AppExpr: Rc<RefCell<Ast<'input>>> = {
    AtomicExpr,
    <expr: AtomicExpr> <exprs: AtomicExpr+> => Rc::new(RefCell::new(Ast::App { head: expr, children: exprs }))
}

InfixExpr: Rc<RefCell<Ast<'input>>> = {
    AppExpr,
    <lhs: AppExpr> <op: "operator"> <rhs: InfixExpr> => Rc::new(RefCell::new(Ast::Operator(lhs, op, rhs)))
}

pub Ast: Rc<RefCell<Ast<'input>>> = {
    InfixExpr,
    "let" <defs: LetFuncDef+> "in" <body: Ast> => Rc::new(RefCell::new(Ast::Let(LetType::NonRec, defs, body))),
    "letrec" <defs: LetFuncDef+> "in" <body: Ast> => Rc::new(RefCell::new(Ast::Let(LetType::Rec, defs, body))),
}

pub LetFuncDef: Rc<RefCell<FuncDef<'input>>> = {
    <name: "identifier"> <params: "identifier"*> "=" <a: Ast> ";" => {
        Rc::new(RefCell::new(FuncDef { name, params, body: a }))
    }
}
